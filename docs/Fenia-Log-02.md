<pre>
Ancifer произносит 'расскажи, пожалуйста, про потоки, если не трудно :)'

Filths произносит 'ща , я тут в редакторе'

Ancifer произносит 'хотел поспрашивать по задержкам. Как их реализовывать? Нашел в одной из мобпрог delay, но не понял как реализовано. Что-то там с потоками, вроде?'

Filths произносит 'да. yield можно делать только в потоках'

Ancifer произносит 'соответственно там же .tmp.system.sleep()'

Ancifer произносит 'мне нужен простенький способ сделать задержку в 1-2 секунды :) Пытался nop'ами, как в асме, но не получилось :)'

Filths произносит '.tmp.system.sleep это враппер на фене. тупо цикл от нуля до числа переданного в параметры с yield'ом в теле'

Filths произносит 'само собой. время стоит пока не завершится триггер. ща объясню про потоки..'

Filths произносит 'в общем, муд - игра пошаговая. она выросла из настольных игр.. там все ходят по очереди'

Filths произносит 'длинна шага в муде - четверть секунды. т.н пульс'

Filths произносит 'каждый пульс состоит из фаз: прочитать команды из сокетов, выполнить по одной команде от каждого клиента и бработать все тики в мире (файт апдэйт, ареа апдэйт и т.п.)'

Filths произносит 'это все подразумевает однопотоковую систему. т.е. один единственный поток обслуживает всех клиентов и делает все насвете'

Filths произносит 'так. на чем я остановился :)'

Filths произносит 'а, да'

Ancifer произносит ':)'

Filths произносит 'блин. на четыре фронта общаюсь :) Тяжело. в общем, тригера вызываются из этого главного потока'

Filths произносит 'так же как и eval'

Filths произносит 'из всего описанного понятно, что пока триггер не закончится, никто ничего не увидит и вообще ничего не произойдет во всем мире?'

Ancifer произносит 'понятно'

Filths произносит 'т.е. вариант с циклом и нопами - тупиковый ход. особенно, если надо ждать какого-то события'

Filths произносит 'чтоб не нарушать всю истему с пошаговым выполнением команд, феневые потоки обавляют просто еще одну стадию в главный цикл'

Filths произносит 'каждый поток созданный феней ожидает своей очереди, а не выполняется одновременно с другими потоками и главным циклом.'

Filths произносит 'в программировании это называется невытисняющая многозадачность'

Filths произносит 'когда переключение между задачами осуществляется не автоматически, когда истечет время отведенное для нее, а тогда, когда текущая задача сама об этом попросит.'

Filths произносит 'итак, имеем главный поток, который крутится в главном цикле и кучу феневых потоков, которые ждут своей очереди.'

Filths произносит 'в конце каждого пульса, главный поток уступает место следующему (феневому) потоку.'

Filths произносит 'феневый поток выполняет функцию, которую в него передали до тех пор, пока она не завершится, либо из нее не будет вызван метод .scheduler.yield()'

Filths произносит 'если вызван метод .scheduler.yield(), текущий поток приостанавливается и продолжает выполнение следующий'

Filths произносит 'когда последний феневый поток приостановится, управление возвращается в главный поток и цикл начинается сначала'

Filths произносит 'все понятно?'

Ancifer произносит 'почти. Я только что почитал ещ╓ логи с Киндой, ты там написал, что между йилдами нельзя ничего выполнять. А тут ты говоришь, что йилд передает управление следующему потоку'

Filths произносит 'я говорил, что между yield ничего не происходит, помимо того, что написано в твоей проге.'

Ancifer произносит 'не понял. Допустим, в моей проге написано ch.act("bebe")'

Ancifer произносит 'не понял. Допустим, в моей проге написано ch.act("bebe"); .tmp.yield() - что произойдет?'

Filths произносит 'напечатается bebe и будет пауза в один пульс'

Ancifer произносит 'а в окружающем мире? Т.е. шло выполнение основног потока. Прош╓л пульс, выполнился  act(bebe), закончилось выполнение порожденного потока, потом пошел второй пульс, так?'

Filths произносит 'потоки не завершаются, но приостанавливаются. потом продолжают с того же места. суть в том, что в любой момент реального времени, выполняется ровно один поток. они переключаются между собой только с помощью yield'

Filths произносит 'переключение происходит покругу'

Filths произносит 'в конце главного цикла главного потока делается yield. и пока все феневые потоки не сделают yield, главный поток не продолжится'

Ancifer произносит 'т.е. в дочернем потоке происходит всякая фигня. Она будет происходить до тех пор, пока мы не вызовем yield. И если его не вызывать, то мы так и будем бесконечно ждать вызова. Так?'

Filths произносит '"мы" == все остальные потоки, включая главный'

Ancifer произносит 'а как подождать два пульс? Два раза вызвать поток?'

Ancifer произносит 'новый поток всмысле создать'

Filths произносит 'два раза вызвать yield!'

Filths произносит 'зачем новый поток создавать? я ж говорю - при yield поток не завершается. он приостанавливается на время, пока выполняются остальные потоки'

Ancifer произносит 'так... а синтаксис какой у потоков?'

Filths произносит 'ну, это к синтаксису отношения не имеет. апи.'

Filths произносит 'ptc(.scheduler.api())'

Ancifer произносит 'окей'

Filths произносит 'там есть ф-я .scheduler.Thread, ей передается ф-я потока, которую надо запустить в новом потоке, кроме этого в Thread передается произвольное количество аргументов'

Filths произносит 'которые как есть передаются в ф-ю потока '

</pre>